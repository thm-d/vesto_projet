{"ast":null,"code":"var removeDiacritics = require('diacritic').clean; // https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters\n\n\nvar specialCharsRegex = /[.*+?^${}()|[\\]\\\\]/g; // http://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.6\n\nvar wordCharacterRegex = /[a-z0-9_]/i;\nvar whitespacesRegex = /\\s+/;\n\nfunction escapeRegexCharacters(str) {\n  return str.replace(specialCharsRegex, '\\\\$&');\n}\n\nfunction extend(subject, baseObject) {\n  subject = subject || {};\n  Object.keys(subject).forEach(function (key) {\n    baseObject[key] = !!subject[key];\n  });\n  return baseObject;\n}\n\nmodule.exports = function match(text, query, options) {\n  options = extend(options, {\n    insideWords: false,\n    findAllOccurrences: false,\n    requireMatchAll: false\n  });\n  var cleanedTextArray = Array.from(text).map(function (x) {\n    return removeDiacritics(x);\n  });\n  var cleanedText = cleanedTextArray.join('');\n  query = removeDiacritics(query);\n  return query.trim().split(whitespacesRegex) // If query is blank, we'll get empty string here, so let's filter it out.\n  .filter(function (word) {\n    return word.length > 0;\n  }).reduce(function (result, word) {\n    var wordLen = word.length;\n    var prefix = !options.insideWords && wordCharacterRegex.test(word[0]) ? '\\\\b' : '';\n    var regex = new RegExp(prefix + escapeRegexCharacters(word), 'i');\n    var occurrence, index;\n    occurrence = regex.exec(cleanedText);\n\n    if (options.requireMatchAll && occurrence === null) {\n      cleanedText = '';\n      return [];\n    }\n\n    while (occurrence) {\n      index = occurrence.index;\n      var cleanedLength = cleanedTextArray.slice(index, index + wordLen).join('').length;\n      var offset = wordLen - cleanedLength;\n      var initialOffset = index - cleanedTextArray.slice(0, index).join('').length;\n      var wordOffset = offset;\n      var indexes = [index + initialOffset, index + wordLen + initialOffset + wordOffset];\n\n      if (indexes[0] !== indexes[1]) {\n        result.push(indexes);\n      } // Replace what we just found with spaces so we don't find it again.\n\n\n      cleanedText = cleanedText.slice(0, index) + new Array(wordLen + 1).join(' ') + cleanedText.slice(index + wordLen);\n\n      if (!options.findAllOccurrences) {\n        break;\n      }\n\n      occurrence = regex.exec(cleanedText);\n    }\n\n    return result;\n  }, []).sort(function (match1, match2) {\n    return match1[0] - match2[0];\n  });\n};","map":{"version":3,"sources":["/Users/thomasd./test_technique_stock/node_modules/autosuggest-highlight/match/index.js"],"names":["removeDiacritics","require","clean","specialCharsRegex","wordCharacterRegex","whitespacesRegex","escapeRegexCharacters","str","replace","extend","subject","baseObject","Object","keys","forEach","key","module","exports","match","text","query","options","insideWords","findAllOccurrences","requireMatchAll","cleanedTextArray","Array","from","map","x","cleanedText","join","trim","split","filter","word","length","reduce","result","wordLen","prefix","test","regex","RegExp","occurrence","index","exec","cleanedLength","slice","offset","initialOffset","wordOffset","indexes","push","sort","match1","match2"],"mappings":"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","sourcesContent":["var removeDiacritics = require('diacritic').clean;\n\n// https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters\nvar specialCharsRegex = /[.*+?^${}()|[\\]\\\\]/g;\n\n// http://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.6\nvar wordCharacterRegex = /[a-z0-9_]/i;\n\nvar whitespacesRegex = /\\s+/;\n\nfunction escapeRegexCharacters(str) {\n  return str.replace(specialCharsRegex, '\\\\$&');\n}\n\nfunction extend(subject, baseObject) {\n  subject = subject || {};\n  Object.keys(subject).forEach(function(key) {\n    baseObject[key] = !!subject[key];\n  });\n  return baseObject;\n}\n\nmodule.exports = function match(text, query, options) {\n  options = extend(options, {\n    insideWords: false,\n    findAllOccurrences: false,\n    requireMatchAll: false\n  });\n\n  var cleanedTextArray = Array.from(text).map(function(x) {\n    return removeDiacritics(x);\n  });\n  var cleanedText = cleanedTextArray.join('');\n\n  query = removeDiacritics(query);\n\n  return (\n    query\n      .trim()\n      .split(whitespacesRegex)\n      // If query is blank, we'll get empty string here, so let's filter it out.\n      .filter(function(word) {\n        return word.length > 0;\n      })\n      .reduce(function(result, word) {\n        var wordLen = word.length;\n        var prefix =\n          !options.insideWords && wordCharacterRegex.test(word[0]) ? '\\\\b' : '';\n        var regex = new RegExp(prefix + escapeRegexCharacters(word), 'i');\n        var occurrence, index;\n\n        occurrence = regex.exec(cleanedText);\n        if (options.requireMatchAll && occurrence === null) {\n          cleanedText = '';\n          return [];\n        }\n\n        while (occurrence) {\n          index = occurrence.index;\n\n          var cleanedLength = cleanedTextArray\n            .slice(index, index + wordLen)\n            .join('').length;\n          var offset = wordLen - cleanedLength;\n\n          var initialOffset =\n            index - cleanedTextArray.slice(0, index).join('').length;\n          var wordOffset = offset;\n\n          var indexes = [\n            index + initialOffset,\n            index + wordLen + initialOffset + wordOffset\n          ];\n\n          if (indexes[0] !== indexes[1]) {\n            result.push(indexes);\n          }\n\n          // Replace what we just found with spaces so we don't find it again.\n          cleanedText =\n            cleanedText.slice(0, index) +\n            new Array(wordLen + 1).join(' ') +\n            cleanedText.slice(index + wordLen);\n\n          if (!options.findAllOccurrences) {\n            break;\n          }\n\n          occurrence = regex.exec(cleanedText);\n        }\n\n        return result;\n      }, [])\n      .sort(function(match1, match2) {\n        return match1[0] - match2[0];\n      })\n  );\n};\n"]},"metadata":{},"sourceType":"script"}